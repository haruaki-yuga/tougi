<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バトルシミュレーション</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
        }

        h1 {
            text-align: left;
        }

        form {
            margin-bottom: 5px;
        }

        label {
            font-size: 14px;
            display: inline-block;
            width: 100px;
            /* ラベルの幅を統一 */
        }

        input {
            margin-bottom: 5px;
            font-size: 14px;
            width: 100px;
            /* 入力ボックスの幅を統一 */
        }

        button[type="button"] {
            margin-bottom: 5px;
            /* ボタン間の余白を5pxに調整 */
        }

        select {
            margin-bottom: 5px;
            /* 5pxの余白を追加 */
        }

        #container {
            display: flex;
            justify-content: flex-start;
            /* 左寄せ */
            width: 100%;
            /* コンテナの幅を100%に設定 */
            margin: 0;
            /* 自動的に中央寄せにされないように */
            gap: 10px;
            /* プレイヤー1とプレイヤー2のフォーム、バトルログの間にスペース */
        }

        .player_form {
            width: 250px;
            /* プレイヤーのフォームの幅 */
            margin-right: 3px;
            /* プレイヤー1とプレイヤー2のフォームの間にスペース */
        }

        #battle_log_container {
            display: flex;
            flex-direction: column;
            /* 縦並びにする */
            width: 630px;
            /* バトルログの幅 */
        }

        #battle_log_container h2 {
            font-size: 20px;
            /* タイトルのフォントサイズ */
            margin-bottom: 10px;
            /* タイトルとバトルログ間のスペース */
        }

        #battle_log {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            background-color: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            height: 600px;
            /* ログ画面の高さ */
            overflow-y: scroll;
            font-size: 14px;
            /* フォントサイズ */
        }


        #checkbox_container {
            display: inline-flex;
            align-items: left;
            font-size: 16px;
            cursor: pointer;
        }

        #checkbox_container label {
            display: flex;
            align-items: left;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.2s, box-shadow 0.2s;
            width: 10em;
        }

        #checkbox_container label:hover {
            background-color: #f0f0f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #checkbox_container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }

        .range_label {
            font-size: 14px;
            display: inline-block;
            width: 8em;
        }

        .range_container label {
            display: flex;
            align-items: left;
            padding: 5px 5px 0px 5px;
            width: 1em;
        }

        .range_container input {
            width: 1em;
        }

        .range_container {
            display: flex;
            justify-content: left;
            align-items: left;
            gap: 10px;
            height: 3em;
        }

        .range_item {
            display: flex;
            flex-direction: column;
            align-items: left;
        }

        .element_label {
            font-size: 14px;
            display: inline-block;
            width: 8em;
        }

        .element_level_input {
            width: 4em;
        }
    </style>
</head>

<body>
    <h1>バトルシミュレーション</h1>

    <div id="container">
        <!-- プレイヤー1の入力フォーム -->
        <div class="player_form">
            <h2>プレイヤー1</h2>
            <form id="player1_form">
                <div>
                    <select id="player1_dataSelect">
                        <!-- ここにセーブデータが動的に追加される -->
                    </select>
                </div>
                <div>
                    <button type="button" onclick="saveData('player1')">セーブ</button>
                    <button type="button" onclick="loadData('player1')">ロード</button>
                    <button type="button" onclick="deleteSaveData('player1')">セーブ削除</button>
                </div>
                <div>
                    <button type="button" onclick="exportData('player1')">エクスポート</button>
                    <button type="button" onclick="importData('player1')">インポート</button>
                </div>
                <div><label for="player1_name">名前: </label><input type="text" id="player1_name" value="プレイヤー1" required>
                </div>
                <div><label for="player1_hp">HP: </label><input type="number" id="player1_hp" value="100" required>
                </div>
                <div><label for="player1_ap">AP: </label><input type="number" id="player1_ap" value="10" required></div>
                <div><label for="player1_attack">主攻撃: </label><input type="number" id="player1_attack" value="20"
                        required></div>
                <div><label for="player1_subAttack">副攻撃: </label><input type="number" id="player1_subAttack" value="5"
                        required></div>
                <div><label for="player1_speed">速度: </label><input type="number" id="player1_speed" value="10" required>
                </div>
                <div><label for="player1_critical">クリティカル: </label><input type="number" id="player1_critical" value="5"
                        required></div>
                <div><label for="player1_fumble">ファンブル: </label><input type="number" id="player1_fumble" value="15"
                        required></div>
                <div><label for="player1_drama">ドラマ: </label><input type="number" id="player1_drama" value="10"
                        required></div>
                <div><label for="player1_hit">命中: </label><input type="number" id="player1_hit" value="10" required>
                </div>
                <div><label for="player1_evasion">回避: </label><input type="number" id="player1_evasion" value="5"
                        required></div>
                <div><label for="player1_defense">防御: </label><input type="number" id="player1_defense" value="10"
                        required></div>
                <div><label for="player1_resistance">抵抗: </label><input type="number" id="player1_resistance" value="10"
                        required></div>
                <div><label for="player1_mobility">機動力: </label><input type="number" id="player1_mobility" value="4"
                        required></div>
                <div><span class="element_label">属性</span></div>
                <select id="player1_element" name="player1_element">
                    <option value="火">火</option>
                    <option value="水">水</option>
                    <option value="土">土</option>
                    <option value="風">風</option>
                    <option value="光">光</option>
                    <option value="闇">闇</option>
                    <option value="無">無</option>
                    <option value="-" selected>-</option>
                </select>
                <input type="number" class="element_level_input" id="player1_element_level" value="1" min="1" max="3"
                    required>
                <div><span class="range_label">通常攻撃射程：</span></div>
                <div class="range_container">
                    <div class="range_item">
                        <label for="close">至</label>
                        <input type="checkbox" id="player1_attack_range_check_0" name="player1_attackRange" checked>
                    </div>
                    <div class="range_item">
                        <label for="near">近</label>
                        <input type="checkbox" id="player1_attack_range_check_1" name="player1_attackRange">
                    </div>
                    <div class="range_item">
                        <label for="middle">中</label>
                        <input type="checkbox" id="player1_attack_range_check_2" name="player1_attackRange">
                    </div>
                    <div class="range_item">
                        <label for="far">遠</label>
                        <input type="checkbox" id="player1_attack_range_check_3" name="player1_attackRange" checked>
                    </div>
                    <div class="range_item">
                        <label for="ultra">超</label>
                        <input type="checkbox" id="player1_attack_range_check_4" name="player1_attackRange">
                    </div>
                </div>
            </form>
        </div>

        <!-- プレイヤー2の入力フォーム -->
        <div class="player_form">
            <h2>プレイヤー2</h2>
            <form id="player2_form">
                <div>
                    <select id="player2_dataSelect">
                        　<!-- ここにセーブデータが動的に追加される -->
                    </select>
                </div>
                <div>
                    <button type="button" onclick="saveData('player2')">セーブ</button>
                    <button type="button" onclick="loadData('player2')">ロード</button>
                    <button type="button" onclick="deleteSaveData('player2')">セーブ削除</button>
                </div>
                <div>
                    <button type="button" onclick="exportData('player2')">エクスポート</button>
                    <button type="button" onclick="importData('player2')">インポート</button>
                </div>
                <div><label for="player2_name">名前: </label><input type="text" id="player2_name" value="プレイヤー2" required>
                </div>
                <div><label for="player2_hp">HP: </label><input type="number" id="player2_hp" value="100" required>
                </div>
                <div><label for="player2_ap">AP: </label><input type="number" id="player2_ap" value="10" required></div>
                <div><label for="player2_attack">主攻撃: </label><input type="number" id="player2_attack" value="20"
                        required></div>
                <div><label for="player2_subAttack">副攻撃: </label><input type="number" id="player2_subAttack" value="5"
                        required></div>
                <div><label for="player2_speed">速度: </label><input type="number" id="player2_speed" value="10" required>
                </div>
                <div><label for="player2_critical">クリティカル: </label><input type="number" id="player2_critical" value="5"
                        required></div>
                <div><label for="player2_fumble">ファンブル: </label><input type="number" id="player2_fumble" value="15"
                        required></div>
                <div><label for="player2_drama">ドラマ: </label><input type="number" id="player2_drama" value="10"
                        required></div>
                <div><label for="player2_hit">命中: </label><input type="number" id="player2_hit" value="10" required>
                </div>
                <div><label for="player2_evasion">回避: </label><input type="number" id="player2_evasion" value="5"
                        required></div>
                <div><label for="player2_defense">防御: </label><input type="number" id="player2_defense" value="10"
                        required></div>
                <div><label for="player2_resistance">抵抗: </label><input type="number" id="player2_resistance" value="10"
                        required></div>
                <div><label for="player2_mobility">機動力: </label><input type="number" id="player2_mobility" value="4"
                        required></div>
                <div><span class="element_label">属性</span></div>
                <select id="player2_element" name="player2_element">
                    <option value="火">火</option>
                    <option value="水">水</option>
                    <option value="土">土</option>
                    <option value="風">風</option>
                    <option value="光">光</option>
                    <option value="闇">闇</option>
                    <option value="無">無</option>
                    <option value="-" selected>-</option>
                </select>
                <input type="number" class="element_level_input" id="player2_element_level" value="1" min="1" max="3"
                    required>
                <div><span class="range_label">通常攻撃射程：</span></div>
                <div class="range_container">
                    <div class="range_item">
                        <label for="close">至</label>
                        <input type="checkbox" id="player2_attack_range_check_0" name="player2_attackRange" checked>
                    </div>
                    <div class="range_item">
                        <label for="near">近</label>
                        <input type="checkbox" id="player2_attack_range_check_1" name="player2_attackRange">
                    </div>
                    <div class="range_item">
                        <label for="middle">中</label>
                        <input type="checkbox" id="player2_attack_range_check_2" name="player2_attackRange">
                    </div>
                    <div class="range_item">
                        <label for="far">遠</label>
                        <input type="checkbox" id="player2_attack_range_check_3" name="player2_attackRange" checked>
                    </div>
                    <div class="range_item">
                        <label for="ultra">超</label>
                        <input type="checkbox" id="player2_attack_range_check_4" name="player2_attackRange">
                    </div>
                </div>
            </form>
        </div>
        <div id="battle_log_container">
            <h2>バトルログ</h2>
            <div id="battle_log"></div>
        </div>
    </div>

    <div id="initial_range_meter_container"><label for="initial_range_meter">開始時距離(m): </label><input type="number"
            id="initial_range_meter" min="0" value="30" required>
        </select></div>

    <button onclick="startBattle()">バトル開始</button>
    <button onclick="clearBattleLog()">ログをクリア</button>
    <div id="checkbox_container">
        <label for="result_check">
            <input type="checkbox" id="result_check" name="result_check" checked>
            勝敗判定を行う
        </label>
    </div>

    <h2>バトル結果</h2>
    <div id="result"></div>
    <script>
        let rangeMeter;

        // レンジに対応する距離範囲を定義
        const rangeConditions = [
            distance => distance >= 0 && distance <= 3,      // 至近距離
            distance => distance >= 0 && distance <= 10,     // 近距離
            distance => distance >= 0 && distance <= 20,     // 中距離
            distance => distance >= 20 && distance <= 30,    // 遠距離
            distance => distance >= 30 && distance <= 40     // 超遠距離
        ];

        // レンジごとの補正を定義
        const rangeFix = {
            0: { 0: 10 },                          // 至近距離の補正
            1: { 0: 7, 1: 7 },                     // 近距離の補正
            2: { 0: 5, 1: 5, 2: 10 },              // 中距離の補正
            3: { 0: -10, 1: -10, 2: 5, 3: 5 },     // 遠距離の補正
            4: { 2: -10, 3: 5, 4: 5 }              // 超遠距離の補正
        };

        // レンジごとの適正距離を定義
        const optimalTargetDistance = {
            normal: {
                0: 0,
                1: 10,
                2: 20,
                3: 30,
                4: 40,
            },
            // 近めで戦う(不使用)
            near: {
                0: 0,
                1: 4,
                2: 11,
                3: 21,
                4: 31,
            },
            // 離れて戦う(不使用)
            far: {
                0: 3,
                1: 10,
                2: 20,
                3: 30,
                4: 40,
            }
        }

        const HIT_DEGREE = {
            GRAZE_HIT: 1,
            LIGHT_HIT: 2,
            CLEAN_HIT: 3,
            HARD_HIT: 4,
            SMASH_HIT: 5,
        };

        // valueがn以上m以下であるならtrue、違うならfalseを返す
        // console.log(isInRange(5, 1, 10));  // true (5は1以上10以下)
        function isInRange(value, n, m) {
            return value >= n && value <= m;
        }

        class Character {
            constructor(name, hp, ap, mainAttack, subAttack, speed, critical, fumble, drama, hit, evasion, defense, resistance, mobility, element, elementLevel, compatibleRange) {
                this.name = name;
                this.initialHp = hp;
                this.hp = hp;
                this.ap = ap;
                this.mainAttack = mainAttack;
                this.subAttack = subAttack;
                this.speed = speed;
                this.critical = critical;
                this.fumble = fumble;
                this.drama = drama;
                this.hit = hit;
                this.evasion = evasion;
                this.defense = defense;
                this.resistance = resistance;
                this.mobility = mobility;
                this.element = element;
                this.elementLevel = elementLevel;
                this.compatibleRange = compatibleRange;

                this.alive = true;
                this.passed = false;
                this.actionPoints = 0;
                this.yojoPoints = 0;
                this.dramaEnhanceCount = 0;
                this.cleanHitOverCountForJudge = 0;
                this.damageScoreForJudge = 0;
                this.judgePoints = 0;
                this.nextAction = null;
                this.rangeHitFix;
            }

            // ダメージを受けるメソッド
            takeDamage(damage, trueDamage, judgeHitDegree, defenseFumble, element, elementLevel) {

                this.takeDamagePreProcess(judgeHitDegree);

                if (this.defense >= 0) {
                    if (!defenseFumble) {
                        let defenseChance = Math.random() * 100;
                        if ((defenseChance >= (100 - this.critical) || defenseChance >= (100 - this.defense)) && defenseChance > this.fumble) {
                            damage *= 0.3;
                            log(`${this.name}は防御技術でダメージを軽減しました！`);
                        }
                    }
                } else {
                    switch (true) {
                        case isInRange(this.defense, -10, -1): {
                            damage *= 1.2;
                            break;
                        }
                        case isInRange(this.defense, -20, -11): {
                            damage *= 1.4;
                            break;
                        }
                        case isInRange(this.defense, -30, -21): {
                            damage *= 1.6;
                            break;
                        }
                        case isInRange(this.defense, -40, -31): {
                            damage *= 1.8;
                            break;
                        }
                        default: {
                            damage *= 2;
                        }
                    }
                }

                if (this.resistance >= 0) {
                    let resistanceChance = Math.random() * 100;
                    if (resistanceChance >= (100 - this.resistance)) {
                        log(`${this.name}は状態異常に対する抵抗が発動しました！`);
                    } else {
                        // BS適用処理
                    }
                } else {
                    // 特殊抵抗がマイナスでBSを受けた場合、特殊抵抗判定に移行します。
                    // -抵抗値+100で抵抗判定を行い、失敗時BSの効果ターンが二倍となります。この判定は速度判定と同様にクリティカルとファンブルは起きません。-101を超えた場合、必ず失敗します。 例：抵抗-5の場合、-5+100で95の特殊判定に失敗すると（出目が4以下の場合）、BS効果ターンが二倍となります。
                    // 特殊抵抗が-1～-50である間、受けるBS効果は一段階上昇します。
                    // 特殊抵抗が-51～-100である場合、更にもう一段階上昇……という形でBSの効果が悪化していきます。
                    // 最大で四段階目のBSの効果に悪化します。（三段階の系統、上位がないBSも存在します）
                    // 例：-1～-25で【毒】を付与された場合→【猛毒】の効果に。
                    // 例：-26～-50で【毒】を付与された場合→【致死毒】の効果に。
                    // 例：-51～で【毒】を付与された場合→【廃滅】の効果に。
                    // 特殊抵抗がマイナスである場合BSの耐性を所持していた場合でも、その耐性は無効化されBSの効果が発動します。。
                    // HP増量系の付与効果をブレイク時、付与されていたHP分が消滅します。（自然な時間経過で付与効果が消えた場合はHPは減りません）

                    // 25刻みと50刻みで表記が揺れているが、
                    // pppの記述を確認したところロスアカ以降にあたっての表記揺れと判明
                    // 一旦25刻みで悪化する方向で処理している

                    let resistanceChance = Math.random() * 100;
                    if (resistanceChance >= (100 - this.resistance + 100)) {
                        // BS効果時間は等倍
                    } else {
                        // BS効果時間は二倍
                    }

                    switch (true) {
                        case isInRange(this.defense, -25, -1): {
                            // 最大一段階悪化
                            break;
                        }
                        case isInRange(this.defense, -50, -26): {
                            // 最大二段階悪化
                            break;
                        }
                        default: {
                            // 最大三段階悪化
                            break;
                        }
                    }
                    // BS適用処理
                }

                const elementFix = this.getElementFix(element, elementLevel);

                damage = Math.round((damage + trueDamage) * elementFix);

                this.hp -= damage;
                log(`${this.name}は${damage}ダメージを受けました！\n`);

                if (this.hp <= 0) {
                    let dramaChance = Math.random() * 100;
                    if ((dramaChance >= (100 - this.critical) || dramaChance >= (100 - this.drama)) && dramaChance > this.fumble) {
                        this.hp = 1;
                        if (this.dramaEnhanceCount < 5) {
                            this.mainAttack += 40;
                            this.subAttack += 40;
                            this.critical += 2;
                            this.speed += 40;
                            this.dramaEnhanceCount += 1;
                            log(`${this.name}はドラマ補正でHP1で踏みとどまり、主攻撃力、副攻撃力、クリティカル、速度が増加しました！`);
                        } else {
                            log(`${this.name}はドラマ補正でHP1で踏みとどまりました！`);
                        }
                    } else {
                        this.hp = 0;
                        this.alive = false;
                        log(`${this.name}は倒れました！`);
                    }
                }

                this.takeDamagePostProcess(judgeHitDegree);

                // 与えたダメージ量を返却
                return damage
            }

            // 属性補正倍率を取得
            // this.element = ダメージを受ける側の属性
            // element = ダメージを与える側の属性
            getElementFix(element, elementLevel) {
                let percentage = 100;
                switch (this.element) {
                    case '火': {
                        // 弱点となる方
                        if (element === '水') {
                            percentage = 100 + elementLevel * 5
                        }
                        // 耐性がある方
                        if (element === '風') {
                            percentage = 100 - this.elementLevel * 5
                        }
                        break;
                    }
                    case '水': {
                        // 弱点となる方
                        if (element === '土') {
                            percentage = 100 + elementLevel * 5
                        }
                        // 耐性がある方
                        if (element === '火') {
                            percentage = 100 - this.elementLevel * 5
                        }
                        break;
                    }
                    case '土': {
                        // 弱点となる方
                        if (element === '風') {
                            percentage = 100 + elementLevel * 5
                        }
                        // 耐性がある方
                        if (element === '水') {
                            percentage = 100 - this.elementLevel * 5
                        }
                        break;
                    }
                    case '風': {
                        // 弱点となる方
                        if (element === '火') {
                            percentage = 100 + elementLevel * 5
                        }
                        // 耐性がある方
                        if (element === '土') {
                            percentage = 100 - this.elementLevel * 5
                        }
                        break;
                    }
                    case '光': {
                        // 弱点となる方
                        if (element === '闇') {
                            percentage = 100 + elementLevel * 7
                        }
                        break;
                    }
                    case '闇': {
                        // 弱点となる方
                        if (element === '光') {
                            percentage = 100 + elementLevel * 7
                        }
                        break;
                    }
                    case '無': {
                        // 弱点となる方
                        if (element === '光') {
                            percentage = 100 + elementLevel * 3
                        } else if (element === '闇') {
                            percentage = 100 + elementLevel * 3
                        }
                    }
                }
                return percentage / 100;
            }

            takeDamagePreProcess(judgeHitDegree) {
                switch (judgeHitDegree) {
                    case HIT_DEGREE.GRAZE_HIT: {
                        this.resistance += 50;
                        break;
                    }
                    case HIT_DEGREE.LIGHT_HIT: {
                        this.resistance += 30;
                        break;
                    }
                    case HIT_DEGREE.CLEAN_HIT: {
                        this.resistance += 0;
                        this.drama -= 25;
                        break;
                    }
                    case HIT_DEGREE.HARD_HIT: {
                        this.resistance -= 25;
                        this.drama -= 50;
                        break;
                    }
                    case HIT_DEGREE.SMASH_HIT: {
                        this.resistance -= 50;
                        this.drama -= 100;
                        break;
                    }
                    default: {
                        throw new Error(`judgeHitDegree:${judgeHitDegree}`);
                    }
                }
            }

            takeDamagePostProcess(judgeHitDegree) {
                switch (judgeHitDegree) {
                    case HIT_DEGREE.GRAZE_HIT: {
                        this.resistance -= 50;
                        break;
                    }
                    case HIT_DEGREE.LIGHT_HIT: {
                        this.resistance -= 30;
                        break;
                    }
                    case HIT_DEGREE.CLEAN_HIT: {
                        this.resistance += 0;
                        this.drama += 25;
                        break;
                    }
                    case HIT_DEGREE.HARD_HIT: {
                        this.resistance += 25;
                        this.drama += 50;
                        break;
                    }
                    case HIT_DEGREE.SMASH_HIT: {
                        this.resistance += 50;
                        this.drama += 100;
                        break;
                    }
                    default: {
                        throw new Error(`judgeHitDegree:${judgeHitDegree}`);
                    }
                }
            }

            // 行動可能かをチェック
            isAlive() {
                return this.alive;
            }

            // 行動力を決める
            rollInitiative() {
                let roll1 = Math.floor(Math.random() * 100) + 1;
                let roll2 = Math.floor(Math.random() * 100) + 1;
                this.actionPoints = this.speed + roll1 + roll2 + this.yojoPoints;
                log(`${this.name}のHP:${this.hp} 行動力:${this.actionPoints}(速度:${this.speed}+ダイス1:${roll1}+ダイス2:${roll2}+繰り越し分:${this.yojoPoints})`);
            }

            move() {
                // 現在の距離(m)
                let currentDistance = rangeMeter;
                // 移動可能な最大距離(m)
                let movableMeter = this.mobility * 10;

                // 目標地点を探索
                const findTargetPoint = (targetDistances, maxDistance) => {
                    let targetPoint = null;
                    let shortestDistance = Infinity;

                    // 射程ごとにチェック
                    for (const [range, target] of Object.entries(targetDistances)) {
                        const rangeIndex = parseInt(range, 10);
                        const distanceToTarget = Math.abs(target - rangeMeter);

                        if (
                            this.compatibleRange[rangeIndex] && // 対応可能な射程か
                            distanceToTarget <= maxDistance && // 移動可能距離内か
                            distanceToTarget < shortestDistance // 最短距離か
                        ) {
                            targetPoint = target;
                            shortestDistance = distanceToTarget;
                        }
                    }

                    return targetPoint;
                };

                // 最適な目標位置を探す
                const targetPosition = findTargetPoint(optimalTargetDistance.normal, movableMeter);

                // 条件を満たす位置が見つからなければ最大距離を移動
                if (targetPosition === null) {
                    rangeMeter = rangeMeter - movableMeter;
                } else {
                    rangeMeter = targetPosition;
                }
                log(`${this.name}は${rangeMeter}mの座標まで移動！`);
                this.actionPoints -= 20;
            }

            attack(target, consumeActionPoints) {
                this.attackPreProcess();
                // 射程外の場合は攻撃できない
                if (!this.withinNormalAttackRange()) {
                    return;
                }
                let attackCritical = false
                let attackFumble = false
                let defenseCritical = false
                let defenseFumble = false

                // ① 命中判定
                let roll = Math.floor(Math.random() * 100) + 1; // 100面ダイスを振る
                let hitChance = this.hit + roll; // 命中判定数値

                // ② 回避判定
                let evasionRoll = Math.floor(Math.random() * 100) + 1; // 回避判定用ダイスを振る
                let finalEvasion = evasionRoll + target.evasion; // 最終的な回避数値

                if (roll >= 100 - this.critical) {
                    attackCritical = true
                }
                if (roll <= this.fumble) {
                    attackFumble = true
                }
                if (evasionRoll >= 100 - target.critical) {
                    defenseCritical = true
                }
                if (evasionRoll <= target.fumble) {
                    defenseFumble = true
                }

                // ③ ログ出力: 命中ダイスと命中値、回避判定ダイスと回避値を表示
                if (roll <= this.fumble) {
                    log(`\n${this.name}が攻撃！ 命中判定:ファンブル!! (命中ダイス: ${roll}, 命中: ${this.hit})`);
                } else if (roll >= 100 - this.critical) {
                    log(`\n${this.name}が攻撃！ 命中判定:クリティカル!!(${hitChance}) (命中ダイス: ${roll}, 命中: ${this.hit})`);
                } else {
                    log(`\n${this.name}が攻撃！ 命中判定: ${hitChance} (命中ダイス: ${roll}, 命中: ${this.hit})`);
                }

                if (!attackFumble) {
                    if (evasionRoll <= target.fumble) {
                        log(`${target.name}の回避判定:ファンブル!! (回避ダイス: ${evasionRoll}, 回避: ${target.evasion})`);
                    } else if (evasionRoll >= 100 - target.critical) {
                        log(`${target.name}の回避判定:クリティカル!! (回避ダイス: ${evasionRoll}, 回避: ${target.evasion})`);
                    } else {
                        log(`${target.name}の回避判定: ${finalEvasion} (回避ダイス: ${evasionRoll}, 回避: ${target.evasion})`);
                    }
                }

                // ④ 命中判定と回避判定を比較
                if (defenseCritical) {
                    // クリティカルでの完全回避の場合
                    log(`${target.name}はクリティカルで完全回避しました！`);
                } else if (attackFumble) {
                    // 自動失敗の場合
                    log(`${this.name}の攻撃は失敗しました。\n`);
                } else if (hitChance > finalEvasion) {
                    log(`${target.name}は回避に失敗し、攻撃が命中しました！`);

                    // ⑤ 再度ダイスを振ってヒット判定を行う
                    let secondRoll = Math.floor(Math.random() * 100) + 1; // 2回目の命中ダイスを振る
                    hitChance += secondRoll; // 命中判定に加算

                    // ⑥ 最終的な命中度を判定するためのダイス

                    let finalHitDegree = hitChance - finalEvasion; // 加算された最終命中度
                    let judgeHitDegree = null;

                    // ログ出力: 最終命中度のダイス結果と最終的な命中度
                    log(`${this.name}の命中度判定ダイス: ${secondRoll}`);
                    log(`${this.name}の最終命中度数値: ${finalHitDegree} (命中判定: ${hitChance}, 命中度ダイス: ${secondRoll})`);

                    // ⑦ ヒットの種類を判定
                    let damage = 0;
                    let trueDamage = 0;
                    if (finalHitDegree <= 49 && !attackCritical) {
                        damage = this.mainAttack * (15 + secondRoll / 4) / 100;
                        judgeHitDegree = HIT_DEGREE.GRAZE_HIT;
                        log(`${this.name}はグレイズヒットで攻撃！`);
                    } else if (finalHitDegree <= 99 || (finalHitDegree <= 49 && attackCritical)) {
                        // 命中判定のクリティカル時はライトヒットを保証
                        damage = this.mainAttack * (30 + secondRoll / 2) / 100;
                        judgeHitDegree = HIT_DEGREE.LIGHT_HIT;
                        log(`${this.name}はライトヒットで攻撃！`);
                    } else if (finalHitDegree <= 149) {
                        if (attackCritical) {
                            damage = this.mainAttack;
                            trueDamage = this.subAttack * 3;
                        } else {
                            damage = this.mainAttack + this.subAttack;
                        }
                        judgeHitDegree = HIT_DEGREE.CLEAN_HIT;
                        log(`${this.name}はクリーンヒットで攻撃！`);
                        this.cleanHitOverCountForJudge++;
                    } else if (finalHitDegree <= 199) {
                        if (attackCritical) {
                            damage = this.mainAttack * (1 + secondRoll / 200);
                            trueDamage = this.subAttack * (1 + secondRoll / 200) * 3;
                        } else {
                            damage = this.mainAttack * (1 + secondRoll / 200);
                            trueDamage = this.subAttack * (1 + secondRoll / 200);
                        }
                        judgeHitDegree = HIT_DEGREE.HARD_HIT;
                        log(`${this.name}はハードヒットで攻撃！`);
                        this.cleanHitOverCountForJudge++;
                    } else {
                        if (attackCritical) {
                            damage = this.mainAttack * (1 + secondRoll / 100);
                            trueDamage = this.subAttack * (1 + secondRoll / 100) * 3;
                        } else {
                            damage = this.mainAttack * (1 + secondRoll / 100);
                            trueDamage = this.subAttack * (1 + secondRoll / 100);
                        }
                        judgeHitDegree = HIT_DEGREE.SMASH_HIT;
                        log(`${this.name}はスマッシュヒットで攻撃！`);
                        this.cleanHitOverCountForJudge++;
                    }

                    // ダメージをターゲットに与える
                    this.damageScoreForJudge += target.takeDamage(damage, trueDamage, judgeHitDegree, defenseFumble, this.element, this.elementLevel);

                } else if (hitChance <= finalEvasion) {
                    // 完全回避の場合
                    log(`${target.name}は完全回避しました！\n`);
                }
                this.actionPoints -= consumeActionPoints; // 攻撃に必要な行動力を消費

                this.attackPostProcess();
            }

            attackPreProcess() {
                this.applyRangeFix();
            }

            attackPostProcess() {
                this.applyRangeFix(true);
            }

            applyRangeFix(postProcess) {

                if (postProcess) {
                    this.hit -= this.rangeHitFix;
                    return;
                }

                // 現在の射程インデックスを特定
                const currentRangeIndex = rangeConditions.findIndex(condition => condition(rangeMeter));

                // 射程対応状況に基づき補正を適用
                for (const [weaponRange, fixes] of Object.entries(rangeFix)) {
                    const weaponRangeIndex = parseInt(weaponRange, 10);

                    // 現在の射程が対応していない場合はスキップ
                    if (!this.compatibleRange[weaponRangeIndex]) continue;

                    // 補正値を適用
                    for (const [targetRange, fixValue] of Object.entries(fixes)) {
                        const targetRangeIndex = parseInt(targetRange, 10);

                        if (targetRangeIndex === currentRangeIndex) {
                            this.rangeHitFix = fixValue;
                        }
                    }
                }

                this.hit += this.rangeHitFix;
            }

            halveProcess() {
                this.actionPoints = Math.floor(this.actionPoints / 2); // 行動力半減
                log(`${this.name}の残り行動力: ${this.actionPoints}`);
            }

            decideAction(targetPlayer) {

                const withinNormalAttackRange = this.withinNormalAttackRange();
                if (this.actionPoints >= 60) {
                    if (!withinNormalAttackRange) {
                        this.nextAction = '移動通常攻撃';
                    } else {
                        this.nextAction = '通常攻撃';
                    }
                }
                if (this.actionPoints < 60) {
                    if (!withinNormalAttackRange) {
                        // 現時点でこの行動値で取る行動を実装していないため持ち越す
                        // 相手が攻撃可能で射程内であれば移動で距離を離す処理を検討する余地あり
                        this.nextAction = '速度を持ち越す';
                    } else {
                        this.nextAction = '通常攻撃';
                    }
                }
                if (this.actionPoints < 40) {
                    // 現時点でこの行動値で取る行動を実装していないため持ち越す
                    // 相手が攻撃可能で射程内であれば移動で距離を離す処理を検討する余地あり
                    this.nextAction = '速度を持ち越す';
                }
                if (this.actionPoints < 20) {
                    this.nextAction = '速度を持ち越す';
                }
            }

            withinNormalAttackRange() {
                // 各射程で対応可能かどうかを確認
                const results = rangeConditions.map((condition, index) => condition(rangeMeter) && this.compatibleRange[index]);
                // 一つでもtrueがあれば対応可能、すべてfalseなら対応不可
                return results.some(result => result);
            }
        }

        let player1, player2;

        function log(message) {
            const battleLog = document.getElementById('battle_log');
            battleLog.textContent += message + '\n';
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        function startBattle() {
            player1 = new Character(
                document.getElementById('player1_name').value,
                parseInt(document.getElementById('player1_hp').value),
                parseInt(document.getElementById('player1_ap').value),
                parseInt(document.getElementById('player1_attack').value),
                parseInt(document.getElementById('player1_subAttack').value),
                parseInt(document.getElementById('player1_speed').value),
                parseInt(document.getElementById('player1_critical').value),
                parseInt(document.getElementById('player1_fumble').value),
                parseInt(document.getElementById('player1_drama').value),
                parseInt(document.getElementById('player1_hit').value),
                parseInt(document.getElementById('player1_evasion').value),
                parseInt(document.getElementById('player1_defense').value),
                parseInt(document.getElementById('player1_resistance').value),
                parseInt(document.getElementById('player1_mobility').value),
                document.getElementById('player1_element').value,
                parseInt(document.getElementById('player1_element_level').value),
                {
                    0: document.getElementById('player1_attack_range_check_0').checked,
                    1: document.getElementById('player1_attack_range_check_1').checked,
                    2: document.getElementById('player1_attack_range_check_2').checked,
                    3: document.getElementById('player1_attack_range_check_3').checked,
                    4: document.getElementById('player1_attack_range_check_4').checked
                }
            );

            player2 = new Character(
                document.getElementById('player2_name').value,
                parseInt(document.getElementById('player2_hp').value),
                parseInt(document.getElementById('player2_ap').value),
                parseInt(document.getElementById('player2_attack').value),
                parseInt(document.getElementById('player2_subAttack').value),
                parseInt(document.getElementById('player2_speed').value),
                parseInt(document.getElementById('player2_critical').value),
                parseInt(document.getElementById('player2_fumble').value),
                parseInt(document.getElementById('player2_drama').value),
                parseInt(document.getElementById('player2_hit').value),
                parseInt(document.getElementById('player2_evasion').value),
                parseInt(document.getElementById('player2_defense').value),
                parseInt(document.getElementById('player2_resistance').value),
                parseInt(document.getElementById('player2_mobility').value),
                document.getElementById('player2_element').value,
                parseInt(document.getElementById('player2_element_level').value),
                {
                    0: document.getElementById('player2_attack_range_check_0').checked,
                    1: document.getElementById('player2_attack_range_check_1').checked,
                    2: document.getElementById('player2_attack_range_check_2').checked,
                    3: document.getElementById('player2_attack_range_check_3').checked,
                    4: document.getElementById('player2_attack_range_check_4').checked,
                }
            );

            rangeMeter = Number(document.getElementById('initial_range_meter').value);

            log(`バトル開始！ ${player1.name} vs ${player2.name}`);

            const suspensionJudgeFlag = document.getElementById('result_check').checked; // 勝敗判定を行うかどうか

            let turn = 1;
            turnLoop: while (player1.isAlive() && player2.isAlive()) {

                if (turn >= 21 && suspensionJudgeFlag) {
                    break;
                }

                log(`\nターン ${turn}:`);
                player1.passed = false;
                player2.passed = false;

                // BS判定フェーズ
                // ダメージバッドステータスのダメージ処理
                // →バッドステータスの自然回復判定
                //【呪い】を受けていない状態で3回の自然回復判定を行うと、そのバッドステータスは消滅する

                // 速度決定フェーズ
                player1.rollInitiative();
                player2.rollInitiative();

                // 行動フェーズ
                let actPlayer, targetPlayer;

                while (!player1.passed && !player2.passed) {

                    // 行動者決定
                    if (player1.actionPoints > player2.actionPoints) {
                        actPlayer = player1;
                        targetPlayer = player2;
                    } else if (player2.actionPoints > player1.actionPoints) {
                        actPlayer = player2;
                        targetPlayer = player1;
                    } else {
                        if (Math.random() < 0.5) {
                            actPlayer = player1;
                            targetPlayer = player2;
                        } else {
                            actPlayer = player2;
                            targetPlayer = player1;
                        }
                    }

                    actPlayer.decideAction(targetPlayer);

                    switch (actPlayer.nextAction) {
                        case '移動通常攻撃': {
                            // 移動が必要な状況で移動
                            actPlayer.move();
                            actPlayer.attack(targetPlayer, 40);
                            if (!actPlayer.isAlive() || !targetPlayer.isAlive()) {
                                break turnLoop;
                            }
                            actPlayer.halveProcess();
                            break;
                        }
                        case '通常攻撃': {
                            // 通常攻撃またはスキル
                            actPlayer.attack(targetPlayer, 40);
                            if (!actPlayer.isAlive() || !targetPlayer.isAlive()) {
                                break turnLoop;
                            }
                            actPlayer.halveProcess();
                            break;
                        }
                        case '速度を持ち越す':
                        default: {
                            if (!actPlayer.passed) {
                                // 速度持ち越し処理
                                actPlayer.passed = true;
                                actPlayer.yojoPoints = actPlayer.actionPoints;
                                if (actPlayer.yojoPoints > actPlayer.speed) {
                                    actPlayer.yojoPoints = actPlayer.speed;
                                }
                                actPlayer.actionPoints = 0;
                            }
                            break;
                        }
                    }

                    if (!actPlayer.isAlive() || !targetPlayer.isAlive()) {
                        break turnLoop;
                    }
                }

                turn++;
            }
            let result = document.getElementById('result');
            if (player1.isAlive() && player2.isAlive()) {
                // 次の項目を1ポイントとし、20ターン経過時にポイントが高い方が勝者。それでも決着が付かない場合は引き分け。

                log(`20ターン終了時に両者生存のため勝敗判定に移行！`);

                // １．与ダメージの総数が多い方
                log(`与ダメージ総計`);
                log(`${player1.name}の与ダメージ総計は${player1.damageScoreForJudge}`);
                log(`${player2.name}の与ダメージ総計は${player2.damageScoreForJudge}`);
                if (player1.damageScoreForJudge > player2.damageScoreForJudge) {
                    log(`${player1.name}に1点！`);
                    player1.judgePoints++;
                } else if (player1.damageScoreForJudge < player2.damageScoreForJudge) {
                    log(`${player2.name}に1点！`);
                    player2.judgePoints++;
                } else {
                    log(`互角！`);
                }

                // ２．クリーンヒット以上の回数が多い方
                log(`クリーンヒット以上の攻撃回数`);
                log(`${player1.name}のクリーンヒット以上の攻撃回数は${player1.cleanHitOverCountForJudge}`);
                log(`${player2.name}のクリーンヒット以上の攻撃回数は${player2.cleanHitOverCountForJudge}`);
                if (player1.cleanHitOverCountForJudge > player2.cleanHitOverCountForJudge) {
                    log(`${player1.name}に1点！`);
                    player1.judgePoints++;
                } else if (player1.cleanHitOverCountForJudge < player2.cleanHitOverCountForJudge) {
                    log(`${player2.name}に1点！`);
                    player2.judgePoints++;
                } else {
                    log(`互角！`);
                }

                // ３．残HPの割合が多い方
                const player1HpPercentage = Math.round(player1.hp / player1.initialHp * 100);
                const player2HpPercentage = Math.round(player2.hp / player2.initialHp * 100);
                log(`残HP割合`);
                log(`${player1.name}のHPは${player1.hp}/${player1.initialHp}(${player1HpPercentage}%)`);
                log(`${player2.name}のHPは${player2.hp}/${player2.initialHp}(${player2HpPercentage}%)`);
                if (Math.round(player1.hp / player1.initialHp * 100) > Math.round(player2.hp / player2.initialHp * 100)) {
                    log(`${player1.name}に1点！`);
                    player1.judgePoints++;
                } else if (Math.round(player1.hp / player1.initialHp * 100) < Math.round(player2.hp / player2.initialHp * 100)) {
                    log(`${player2.name}に1点！`);
                    player2.judgePoints++;
                } else {
                    log(`互角！`);
                }


                log(`${player1.name}の合計ポイントは${player1.judgePoints}！`);
                log(`${player2.name}の合計ポイントは${player2.judgePoints}！`);
                log(`よって……`);
                // 結果の判定
                if (player1.judgePoints > player2.judgePoints) {
                    result.innerHTML = `${player1.name}の勝利！`;
                    return;
                } else if (player1.judgePoints < player2.judgePoints) {
                    result.innerHTML = `${player2.name}の勝利！`;
                    return;
                } else {
                    result.innerHTML = `引き分けです。`;
                    return;
                }
            }
            if ((!player1.isAlive() && !player2.isAlive()) || (player1.isAlive() && player2.isAlive())) {
                result.innerHTML = `引き分けです。`;
            } else if (!player1.isAlive()) {
                result.innerHTML = `${player2.name}の勝利！`;
            } else {
                result.innerHTML = `${player1.name}の勝利！`;
            }
        }
    </script>
    <script>
        // ログをクリアする関数
        function clearBattleLog() {
            const logArea = document.getElementById('battle_log');
            logArea.innerHTML = ''; // ログ内容を空にする
        }

        document.addEventListener('DOMContentLoaded', () => {
            addDefaultCheckEvent('player1');
            addDefaultCheckEvent('player2');
        });

        // どのレンジにもチェックされていない時、至レンジにチェックを入れる
        function addDefaultCheckEvent(playerId) {
            // 全てのチェックボックス要素を取得
            const checkboxes = document.querySelectorAll(`input[name="${playerId}_attackRange"]`);
            const defaultCheckbox = document.getElementById(`${playerId}_attack_range_check_0`);

            // チェックボックスの変更イベントを監視
            checkboxes.forEach((checkbox) => {
                checkbox.addEventListener('change', () => {
                    // すべてのチェック状態を取得
                    const anyChecked = Array.from(checkboxes).some(checkbox => checkbox.checked);

                    // すべてのチェックが外れている場合、デフォルトをチェック
                    if (!anyChecked) {
                        defaultCheckbox.checked = true;
                    }
                });
            });
        }
    </script>
    <script>

        // 初期化: localStorageの"formData"に関連するすべてのデータを取得
        window.addEventListener("load", () => {
            refreshSelectBox();
        });

        // ページを離れる前に実行される処理
        window.addEventListener('beforeunload', (event) => {
            // 入力値を取得
            const player1FormInput = makeJsonObjectFromFormData('player1');
            const player2FormInput = makeJsonObjectFromFormData('player2');
            // JSON形式でlocalStorageに保存
            localStorage.setItem('player1_cache', JSON.stringify(player1FormInput));
            localStorage.setItem('player2_cache', JSON.stringify(player2FormInput));
        });

        // 保存されたデータを復元する
        window.addEventListener('DOMContentLoaded', () => {
            const player1CacheData = localStorage.getItem('player1_cache');
            if (player1CacheData) {
                const parsedData = JSON.parse(player1CacheData);
                reflectToFormData('player1', parsedData);
                localStorage.removeItem('player1_cache');
            };
            const player2CacheData = localStorage.getItem('player2_cache');
            if (player2CacheData) {
                const parsedData = JSON.parse(player2CacheData);
                reflectToFormData('player2', parsedData);
                localStorage.removeItem('player2_cache');
            };
        });

        function refreshSelectBox() {
            const storedKeys = Object.keys(localStorage).filter(key => key.startsWith("formData"));
            let formDataList = [];

            // "formData"とつくデータを取得しリスト化
            storedKeys.forEach(key => {
                const data = JSON.parse(localStorage.getItem(key));
                formDataList.push({ key, ...data });
            });

            // セレクトボックスにデータを追加
            populateSelectBox(document.getElementById("player1_dataSelect"), formDataList);
            populateSelectBox(document.getElementById("player2_dataSelect"), formDataList);
        }

        // セレクトボックスのデータを作成
        function populateSelectBox(selectBox, formDataList) {
            // セレクトボックスをクリア
            selectBox.innerHTML = "<option selected>(選択)</option>";

            // 各formDataをオプションに追加
            formDataList.forEach(data => {
                const option = document.createElement("option");
                option.value = data.key;
                option.textContent = data.name || "(名前なし)";
                selectBox.appendChild(option);
            });

            // 新規作成用オプションを追加
            const newOption = document.createElement("option");
            newOption.value = "new";
            newOption.textContent = "(新規作成)";
            selectBox.appendChild(newOption);
        }

        // データを保存する
        function saveData(playerId) {

            const player1SaveName = document.getElementById(`player1_dataSelect`).value;
            const player2SaveName = document.getElementById(`player2_dataSelect`).value;

            // 入力値を取得
            const inputData = makeJsonObjectFromFormData(playerId);

            let selectedName = document.getElementById(`${playerId}_dataSelect`).value;
            let saveName;
            if (selectedName === "(選択)") {
                return;
            } else if (selectedName === "new") {
                const max = Object.keys(localStorage).filter(key => key.startsWith("formData"))
                    .map(item => {
                        const match = item.match(/^formData(\d+)$/);
                        return match ? parseInt(match[1], 10) : NaN; // 数値を抽出、失敗時はNaN
                    })
                    .filter(num => !isNaN(num)) // NaNを除外
                    .reduce((max, num) => Math.max(max, num), 0);
                saveName = `formData${max + 1}`;
            } else {
                saveName = selectedName;
            }
            // JSON形式でlocalStorageに保存
            localStorage.setItem(saveName, JSON.stringify(inputData));
            // 各セレクトボックスを更新
            refreshSelectBox();

            document.getElementById(`player1_dataSelect`).value = player1SaveName;
            document.getElementById(`player2_dataSelect`).value = player2SaveName;
            if (selectedName === "new") {
                document.getElementById(`${playerId}_dataSelect`).value = saveName;
            }
        }

        function makeJsonObjectFromFormData(playerId) {
            return {
                name: document.getElementById(`${playerId}_name`).value,
                hp: parseInt(document.getElementById(`${playerId}_hp`).value),
                ap: parseInt(document.getElementById(`${playerId}_ap`).value),
                attack: parseInt(document.getElementById(`${playerId}_attack`).value),
                subAttack: parseInt(document.getElementById(`${playerId}_subAttack`).value),
                speed: parseInt(document.getElementById(`${playerId}_speed`).value),
                critical: parseInt(document.getElementById(`${playerId}_critical`).value),
                fumble: parseInt(document.getElementById(`${playerId}_fumble`).value),
                drama: parseInt(document.getElementById(`${playerId}_drama`).value),
                hit: parseInt(document.getElementById(`${playerId}_hit`).value),
                evasion: parseInt(document.getElementById(`${playerId}_evasion`).value),
                defense: parseInt(document.getElementById(`${playerId}_defense`).value),
                resistance: parseInt(document.getElementById(`${playerId}_resistance`).value),
                mobility: parseInt(document.getElementById(`${playerId}_mobility`).value),
                element: document.getElementById(`${playerId}_element`).value,
                elementLevel: parseInt(document.getElementById(`${playerId}_element_level`).value),
                attackRangeChecks: {
                    0: document.getElementById(`${playerId}_attack_range_check_0`).checked,
                    1: document.getElementById(`${playerId}_attack_range_check_1`).checked,
                    2: document.getElementById(`${playerId}_attack_range_check_2`).checked,
                    3: document.getElementById(`${playerId}_attack_range_check_3`).checked,
                    4: document.getElementById(`${playerId}_attack_range_check_4`).checked
                },
                activeSkills: {
                    0: '',
                    1: '',
                    2: '',
                    3: '',
                    4: '',
                }
            };
        }

        // データをロードする
        function loadData(playerId) {
            const saveName = document.getElementById(`${playerId}_dataSelect`).value;
            if (saveName === "(選択)") {
                return;
            }
            const savedData = localStorage.getItem(saveName);
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                reflectToFormData(playerId, parsedData);
            };
        }

        function reflectToFormData(playerId, parsedData) {
            document.getElementById(`${playerId}_name`).value = parsedData.name;
            document.getElementById(`${playerId}_hp`).value = parsedData.hp;
            document.getElementById(`${playerId}_ap`).value = parsedData.ap;
            document.getElementById(`${playerId}_attack`).value = parsedData.attack;
            document.getElementById(`${playerId}_subAttack`).value = parsedData.subAttack;
            document.getElementById(`${playerId}_speed`).value = parsedData.speed;
            document.getElementById(`${playerId}_critical`).value = parsedData.critical;
            document.getElementById(`${playerId}_fumble`).value = parsedData.fumble;
            document.getElementById(`${playerId}_drama`).value = parsedData.drama;
            document.getElementById(`${playerId}_hit`).value = parsedData.hit;
            document.getElementById(`${playerId}_evasion`).value = parsedData.evasion;
            document.getElementById(`${playerId}_defense`).value = parsedData.defense;
            document.getElementById(`${playerId}_resistance`).value = parsedData.resistance;
            document.getElementById(`${playerId}_mobility`).value = parsedData.mobility;
            document.getElementById(`${playerId}_element`).value = parsedData.element;
            document.getElementById(`${playerId}_element_level`).value = parsedData.elementLevel;
            document.getElementById(`${playerId}_attack_range_check_0`).checked = parsedData.attackRangeChecks[0];
            document.getElementById(`${playerId}_attack_range_check_1`).checked = parsedData.attackRangeChecks[1];
            document.getElementById(`${playerId}_attack_range_check_2`).checked = parsedData.attackRangeChecks[2];
            document.getElementById(`${playerId}_attack_range_check_3`).checked = parsedData.attackRangeChecks[3];
            document.getElementById(`${playerId}_attack_range_check_4`).checked = parsedData.attackRangeChecks[4];
        }

        function deleteSaveData(playerId) {

            let saveName = document.getElementById(`${playerId}_dataSelect`).value;
            if (saveName === "new") {
                return;
            }
            // JSON形式でlocalStorageに保存
            localStorage.removeItem(saveName);

            // 各セレクトボックスを更新
            refreshSelectBox();
        }

        // データをエクスポートする
        function exportData(playerId) {
            const jsonData = JSON.stringify(makeJsonObjectFromFormData(playerId), null, 2);
            navigator.clipboard.writeText(jsonData).then(() => { }).catch(err => {
                console.error("データのエクスポートに失敗しました: ", err);
            });
        }

        // データをインポートする
        function importData(playerId) {
            const jsonData = prompt("インポートするデータをペーストしてください:");
            if (!jsonData) return;

            try {
                reflectToFormData(playerId, JSON.parse(jsonData));
            } catch (error) {
                alert("インポートに失敗しました。フォーマットを確認してください。");
                console.error(error);
            }
        }
    </script>
</body>

</html>